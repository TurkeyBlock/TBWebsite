import { createClient } from 'npm:@supabase/supabase-js@2';

function getNewBoard(gameName:string){
  let newBoard;
  if(gameName == "ConnectFour"){
    newBoard = Array(7).fill().map(()=>Array(6).fill(null));
  }
  else if(gameName == "TicTacToe"){
    newBoard = Array(9).fill(null);
  }
  return newBoard;
}

function getNewGame(gameName:string){
  let newGame = {};
  if(gameName == "ConnectFour"){
    newGame = {
      'board':getNewBoard(gameName),
      'nextToken':"X",
      'col':0,
      'row':0
    }
  }
  else if(gameName == "TicTacToe"){
    newGame = {
      'board':getNewBoard(gameName),
      'nextToken':"X"
    }
  }
  return newGame;
}

function validatePlayerTurn(playerIds:string[], currentPlayerIndex:number, requestingPlayerId:string){
  if(playerIds.length > currentPlayerIndex && playerIds[currentPlayerIndex] == requestingPlayerId){
    return true;
  }
  return false;
}

Deno.serve(async (req)=>{
  if (req.method === 'OPTIONS') {
    return new Response('ok', {
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': '*',
        'Access-Control-Allow-Methods': '*'
      },
      status: 200
    });
  }
  try {
    const supabaseClient = createClient(Deno.env.get('SUPABASE_URL') ?? '', Deno.env.get('SUPABASE_ANON_KEY') ?? '', {
      global: {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Headers': '*',
          Authorization: req.headers.get('Authorization')
        }
      }
    });
    // Get the session or user object
    const token = req.headers.get('Authorization')?.replace('Bearer ', '');
    const { data: { user }, error } = await supabaseClient.auth.getUser(token);
    if (error || !user) {
      return new Response(JSON.stringify({
        error: 'Unauthorized'
      }), {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Headers': '*',
          'Content-Type': 'application/json'
        },
        status: 401
      });
    }
    //console.log("Is Authenticated Anonymous = " + user.is_anonymous);
    const keyTable = 'GameKeys';
    const playerTable = 'GamePlayers'
    //-----------------------------------------------------------------------------------------------------------------
    //Begin undertaking requests
    let returnBody = null;
    const supabaseServicer = createClient(Deno.env.get('SUPABASE_URL'), Deno.env.get('SUPABASE_SERVICE_ROLE_KEY'));
    //There is no GET method atm. All GETs are processed as an actionless PATCH.
    //This is because the GET methods don't appear to allow the clients to pass data for their request.
    const reqBody = await req.json();
    if(reqBody.table!=="TicTacToe" && reqBody.table!=="ConnectFour"){
      throw new Error("Unavailable table requested");
    }

    //Used in both PATCH and POST
    let newGamestate;

    if (req.method == 'GET' || req.method == 'PATCH') {
      const { data: gameArray, error:gameArrayError } = await supabaseServicer.from(reqBody.table).select('*').eq('id', reqBody.id).limit(1);

      if (gameArrayError || gameArray.length == 0) { throw new Error("Issue retrieving row using GET/PATCH");}
      const gameName = gameArray[0].name;
      const game = gameArray[0].game; 


      if (req.method == 'GET' || reqBody.action == null) {
        returnBody = game;
      } else{
        //update game
        //confirm that some action was actually requested.
        if (reqBody.action == null) { throw new Error("No action provided");}
        const instructions = reqBody.action.split(" ");
        
        //grab relevant player turn/owner data
        const { data:playerValidatorsArray, error:playerValidatorsArrayError } = await supabaseServicer.from(playerTable).select('playerIds, currentPlayerIndex, maxPlayers').eq('id', reqBody.id).limit(1);
        if(playerValidatorsArrayError){throw new Error("Issue retrieving list of game's players; unable to validate action");}

        const playerIds = playerValidatorsArray[0].playerIds;
        const currentPlayerIndex = playerValidatorsArray[0].currentPlayerIndex;
        const thisUserIndex = playerIds.indexOf(user.id);
        const maxPlayers = playerValidatorsArray[0].maxPlayers;

        if(thisUserIndex==-1){throw new Error("User is not in the game's player list");}

        //Reset action
        if (instructions[0] == "RESET"){
          newGamestate = getNewGame(reqBody.table);
          const { error:resetError } = await supabaseServicer.from(reqBody.table).update({
            game:newGamestate
          }).eq('id', reqBody.id);
          const { error:resetPlayerError } = await supabaseServicer.from(playerTable).update({
            currentPlayerIndex:-1
          }).eq('id', reqBody.id);
        }
        //Move actions
        else if (instructions[0] == "MOVE") {
          //First, validate the user's turn.
          if(!validatePlayerTurn(playerIds,currentPlayerIndex,user.id) && JSON.stringify(game.board)!=JSON.stringify(getNewBoard(reqBody.table))){
            throw new Error("Issue validating requesting player's action in the turn order");
          }

          //Second, validate the action at hand
          if(reqBody.table == "TicTacToe"){
            let position = instructions[1];
            if (game.board[position] == null) {
              let newBoard = game.board;
              newBoard[position] = game.nextToken;
              let newToken = game.nextToken == "X" ? "O" : "X";

              newGamestate = {
                board:newBoard,
                nextToken:newToken
              }
            } else {
              throw new Error("Invalid move requested");
            }
          } 
          else if (reqBody.table == "ConnectFour") {
            let newToken = game.nextToken == "X" ? "O" : "X";
            let col = Number(instructions[1]);
            let rowResult = -1;
            let newBoard = game.board.map((innerArray)=>[
              ...innerArray
            ]);
            for(let i = newBoard[col].length - 1; i >= 0; --i){
              if (newBoard[col][i] == null) {
                newBoard[col][i] = game.nextToken;
                rowResult = i;
                break;
              }
            }
            if (rowResult == -1) {
              throw new Error("Invalid move requested");
            }
            else{
              newGamestate = {
                board:newBoard,
                nextToken:newToken,
                col:col,
                row:rowResult
              }
            }
          }
          const { error:updateError } = await supabaseServicer.from(reqBody.table).update({
            game:newGamestate
          }).eq('id', reqBody.id);

          let nextPlayerIndex = thisUserIndex+1;
          if(nextPlayerIndex >= maxPlayers){
            nextPlayerIndex = 0;
          }
          const { error:currentIndexUpdateError } = await supabaseServicer.from(playerTable).update({
            'currentPlayerIndex':nextPlayerIndex
          }).eq('id', reqBody.id);
        }
      }
    }
    //Creation of a game request
    else{
      if (false/*user.is_anonymous*/) {
        throw new Error("Invalid method; game creation is unavailable to guest accounts");
      }
      else {

        const { data: gameIds, error: searchingError } = await supabaseServicer.from(keyTable).select('id').eq('creatorId', user.id);
        if (searchingError) {
          throw new Error("Failed during search for pre-existing games");
        }

        if (gameIds.length > 0) {
          const gameIdValues = gameIds.map((obj)=>obj.id);
          await supabaseServicer.from(keyTable).delete().in('id', gameIdValues);
        }

        //Create a new KEY row and grab its generated ID
        if (!reqBody.key) {
          reqBody.key = "";
        }

        const { data: newKey, error:keyTableError } = await supabaseServicer.from(keyTable).insert({
          'editKey': reqBody.key,
          'creatorId': user.id
        }).select('*');

        if (keyTableError) {
          console.error('Error inserting data:', keyTableError);
          throw new Error("Failed to create Game keys");
        }
        let newKeyVal = newKey[0].editKey;
        let newIdVal = newKey[0].id;

        //Use generated ID to create corresponding PLAYERS row
        const {error: playerTableError} = await supabaseServicer.from(playerTable).insert({
          'id':newIdVal,
          'playerIds':[null, null]
        });
        if(playerTableError) {
          throw new Error("Failed to create Player Table");
        }

        //Use generated ID to create corresponding GAME row
        newGamestate = getNewGame(reqBody.table);
        const {error: gameTableError } = await supabaseServicer.from(reqBody.table).insert({
          'id': newIdVal,
          'name': 'userTable',
          'game':newGamestate
        });
        if (gameTableError) {
          throw new Error("Failed to create Game Table");
        }
        //Upon successful creation of the rows, send user their game ID.
        returnBody = {
          id: newIdVal,
          key: newKeyVal
        };
      }
    }
    //return the new/current gameState
    return new Response(JSON.stringify({
      returnBody
    }), {
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': '*',
        'Content-Type': 'application/json'
      },
      status: 200
    });
  } catch (error) {
    console.log(error);
    return new Response(JSON.stringify({
      error: error.message
    }), {
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': '*',
        'Content-Type': 'application/json'
      },
      status: 500
    });
  }
});
